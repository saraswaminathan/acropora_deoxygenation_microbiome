---
title: "2_HostAndSymbiontResponse"
author: "Sara Devi Swaminathan"
date: "`r Sys.Date()`"
output: html_document
toc: true
toc_float: true
number_sections: true
---

# Load packages and set working directory

```{r setup}
#-Load necessary libraries-#
library(car)              # Load 'car' for statistical tools and data visualization
library(readxl)           # Load 'readxl' for reading Excel files
library(splitstackshape)  # Load 'splitstackshape' for data splitting, stacking, and reshaping
library(tidyverse)        # Load 'tidyverse' for data manipulation and visualization
library(brms)             # Load 'brms' for Bayesian regression modeling
library(parallel)         # Load 'parallel' for parallel computing
library(bayestestR)       # Load 'bayestestR' for Bayesian hypothesis tests
library(tidybayes)        # Load 'tidybayes' for tidy data handling in Bayesian analyses
library(reshape)          # Load 'reshape' for reshaping and transforming data

#-Write logit function to logit-transform data-#
logit <- function(mu){
  logit.mu <- log(mu/(1-mu))
}
```

#  Data visualization 
- Make custom theme for all plots

```{r}
#-Set theme-#
mytheme <- theme_classic() +                                                   # Start with the classic theme.
  theme(text = element_text(size = 15)) +                                      # Set the overall text size to 15.
  theme(axis.text.x = element_text(size = 15, colour = "black"),               # Set X-axis text size and color.
        axis.text.y = element_text(size = 15, colour = "black")) +             # Set Y-axis text size and color.
  theme(plot.margin = unit(c(5.5, 5.5, 5.5, 15), "pt")) +                      # Set plot margins.
  theme(panel.border = element_rect(colour = "black", fill = NA, size = 1)) +  # Set panel border properties.
  theme(axis.line = element_line(size = 0))                                    # Set the size of axis lines.

#-Set color palette -#
plot.col.treat<-c("0.5" = "#F18D34", "2" = "#F5C75D", "4" =  "#E5EF99", "6" =  "#A5DEDE") # Set colors corresponding to each DO treatment
```

# Read in coral data and format

```{r}
#-Load data frame and format columns-#
physData <- read_xlsx("data/Acer2_forR.xlsx") %>%                              # Read in Excel file and assign it to the variable 'physData'
cSplit("Date", "-") %>%                                                        # Split the 'Date' column using hyphen as a separator
dplyr::rename(Year = Date_1, Month = Date_2, Day = Date_3) %>%                 # Rename the columns as 'Year', 'Month', and 'Day'
mutate(Date = as.Date(mdy(paste(Month, Day, Year)))) %>%                       # Create a new 'Date' column by combining 'Month', 'Day', and 'Year' and converting to Date format

mutate(DayID = as.factor(ifelse(Day %in% c(16, 17, 18), 1,                     # Create a new factor variable 'DayID' based on specific conditions
                    ifelse(Day == 19, 2, 
                           ifelse(Day == 20, 3,
                                  ifelse(Day == 21, 4, 
                                       ifelse(Day == 22, 5, NA))))))) %>% 

mutate(trtNumeric = as.numeric(Treatment),                                     # Create a numeric variable 'trtNumeric' from 'Treatment'
       Treatment = factor(Treatment, levels = c("6", "4", "2", "0.5")),        # Convert 'Treatment' to a factor with specified levels
       trtReverseOrder = factor(Treatment, levels = c("0.5", "2", "4", "6")),  # Create a reversed order factor of 'Treatment'

       Geno = factor(Genotype, order = FALSE),                                 # Convert 'Genotype' to a factor without ordering
       Tank = factor(Tank, order = FALSE),                                     # Convert 'Tank' to a factor without ordering
       FragIDUnique = factor(FragIDUnique, order = FALSE),                                 # Convert 'FragIDUnique' to a factor without ordering
       origin_site = ifelse(origin_site == "MUN", "inshore", "offshore"),      # Recode 'origin_site' based on a condition.
       origin_site = factor(origin_site, levels = c("offshore", "inshore")),   # Convert 'origin_site' to a factor with specified levels
       timepoint = as.factor(timepoint),                                       # Convert 'timepoint' to a factor
       YII_PAM = as.numeric(YII_PAM),                                          # Convert 'YII_PAM' to a numeric variable
       propTissueRemaining = 1 - propTL,                                       # Calculate 'propTissueRemaining' as 1 minus 'propTL'
       F0_PAM = as.numeric(F0_PAM))                                            # Convert 'F0_PAM' to a numeric variable
```

## Make separate dataframe for different response variables

### PAM

```{r}
PAM <-  physData %>%         # Take physiological data
  filter(F0_PAM >= 250) %>%  # Filter PAM data just to valid readings (>250 F0)
  filter(timepoint=="dawn")  # Filter PAM data to just dawn measurements
```

### Tissue retention

```{r}
TL<-physData %>%                                                                                                     # Take physiological data
  filter(timepoint=="peak") %>%                                                                                      # Filter PAM data to just peak measurements, when condition was recorded
  select(FragIDUnique, Day, Tank, DayID, origin_site, Geno, trtNumeric, Treatment, propTL, propTissueRemaining) %>%  # Select specific columns
  arrange(FragIDUnique, Day) %>%                                                                                     # Arrange the dataset by 'FragIDUnique' and 'Day' in ascending order.
  filter(!Day == 16)                                                                                                 # Filter out rows where tissue retention was not measured
```

### Symbiodiniaceae data

```{r}
zooxNoDead <- physData %>%                               # Take physiological data
  filter(timepoint == "peak") %>%                        # Filter rows where 'timepoint' is "peak"
  filter(DayID == 5) %>%                                 # Filter rows where 'DayID' is 5
  mutate(SA = ifelse(SA == 0, .00001, SA),               # Adjust 'SA' values to avoid division by 0 and NaN
         zooxInteger = as.integer(Zoox),                 # Create a new integer variable 'zooxInteger' from 'Zoox'
         zooxTotal = Zoox * SA,                          # Calculate 'zooxTotal' as the product of 'Zoox' and 'SA'
         zooxNorm = zooxTotal * propTissueRemaining) %>% # Calculate 'zooxNorm' based on 'zooxTotal' and 'propTissueRemaining'
         filter(Zoox>0)                                  # Filter to only frags that were sampled at the end of the experiment
```

### Survivorship

```{r}
Surv <- TL%>%                            # Take tissue loss data
  mutate(surv = ifelse(propTL==1, 0, 1), # calculate survival
         mort = ifelse(surv == 1,0,1))   # calculate mortality

#-Dataframe for plotting-#
propSurvTrtSite<-TL %>%
  group_by(DayID, origin_site, Treatment) %>%
  mutate(dummy1 = 1,
         numFrags = sum(dummy1),
         mortality = ifelse(propTL>=0.95, 1, 
                            ifelse(propTL<.95,0, NA))) %>%
  summarise(propMort = sum(mortality)/numFrags)%>%
  unique()%>%
  mutate(propSurv=1-propMort)%>%
  mutate(propSurv = ifelse(DayID=="1", 1, propSurv))
```

## I. PAM figures and models

#### Figure 2A - Boxplots

```{r} 
(dawnPamPlot_noFacet <- PAM %>%                                                             # Take the PAM data
    mutate(DayNew = ifelse(DayID == "1", "0",                                               # Create a new variable 'DayNew' based on 'DayID'
                         ifelse(DayID == "2", "1",
                                ifelse(DayID == "3", "2",
                                       ifelse(DayID == "4", "3",
                                              ifelse(DayID == "5", "4", NA)))))) %>%
  ggplot() +                                                                                # Start a ggplot object
    geom_boxplot(aes(x = DayNew, y = YII_PAM, color = Treatment), size = 1, alpha = 0.5) +  # Create boxplots with specified aesthetics
    geom_jitter(aes(x = DayNew, y = YII_PAM, color = Treatment),                            # Add jittered points with specified aesthetics
                position = position_jitterdodge(jitter.width = NULL,
                                                 jitter.height = 0,
                                                 dodge.width = 0.75,
                                                 seed = NA), size = 1.5) +                  # Specify jitter and dodge settings
    ylim(0.45, 0.7) +                                                                       # Set Y-axis limits
    labs(x = "Day", y = 'Maximum Quantum Yield') +                                          # Set axis labels
    scale_colour_manual(values = plot.col.treat) +                                          # Set manual color scale for Treatment
    scale_fill_manual(values = plot.col.treat) +                                            # Set manual fill scale for Treatment
    mytheme)                                                                                # Apply the custom theme 'mytheme'

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/dawnPamPlot_noFacet.svg", plot = dawnPamPlot_noFacet, width = 7, height = 5) # Save the plot as an SVG file.

```

### Models

```{r}
hist(PAM$YII_PAM)  # Create a histogram of the 'YII_PAM' variable

#-Define a model for YII_PAM and phi using a logistic link function-#
pamDawn_mod_Phi <- bf(YII_PAM ~ 1 + Treatment + Day + origin_site + origin_site * Treatment + (1|FragIDUnique),
                    phi ~ 1 + Treatment + Day + origin_site + origin_site * Treatment + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Define another model for YII_PAM and phi with a simplified structure-#
pamDawn_mod_Phi2 <- bf(YII_PAM ~ 1 + Treatment + Day + origin_site + (1|FragIDUnique),
                    phi ~ 1 + Treatment + Day + origin_site + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Define another model for YII_PAM and phi with further simplification-#
pamDawn_mod_Phi3 <- bf(YII_PAM ~ 1 + Treatment + Day + (1|FragIDUnique),
                    phi ~ 1 + Treatment + Day + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Define another model for YII_PAM and phi, now including DayID-#
pamDawn_mod_Phi4 <- bf(YII_PAM ~ 1 + Treatment + DayID + origin_site + origin_site * Treatment + (1|FragIDUnique),
                    phi ~ 1 + Treatment + DayID + origin_site + origin_site * Treatment + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Define another model for YII_PAM and phi with simplified structure and DayID-#
pamDawn_mod_Phi5 <- bf(YII_PAM ~ 1 + Treatment + DayID + origin_site + (1|FragIDUnique),
                    phi ~ 1 + Treatment + DayID + origin_site + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Define another model for YII_PAM and phi with minimal structure, including DayID-#
pamDawn_mod_Phi6 <- bf(YII_PAM ~ 1 + Treatment + DayID + (1|FragIDUnique),
                    phi ~ 1 + Treatment + DayID + (1|FragIDUnique),
                    family = Beta(link = "logit", link_phi = "log"))

#-Calculate mean of reference group for intercept parameter-#
pamDawn_mean <- PAM %>%
  dplyr::group_by(FragIDUnique) %>%
  dplyr::summarize(meanYield = mean(YII_PAM)) %>%
  mutate(logitMeanYield = logit(meanYield))

print(paste("The logit-transformed propSusc intercept is", round(pamDawn_mean[1,3], 2)))
# "The logit-transformed pamDawn intercept is 0.77"

#-Set priors-#
pamDawn_prior <- c(prior(normal(0.77, 1), class = "Intercept"),
                prior(normal(0, 1), class = "b"),
                prior(exponential(1), class = "sd"),
                prior(normal(0.77, 1), class = "Intercept", dpar = "phi"),
                prior(normal(0, 1), class = "b", dpar = "phi"),
                prior(exponential(1), class = "sd", dpar = "phi"))
                          
#-Run models-#
# pamDawn_brm_Phi <- brm(pamDawn_mod_Phi,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)
# 
# pamDawn_brm_Phi2 <- brm(pamDawn_mod_Phi2,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)
# 
# 
# pamDawn_brm_Phi3 <- brm(pamDawn_mod_Phi3,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)
# 
# pamDawn_brm_Phi4 <- brm(pamDawn_mod_Phi4,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)
# 
# pamDawn_brm_Phi5 <- brm(pamDawn_mod_Phi5,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)
# 
# pamDawn_brm_Phi6 <- brm(pamDawn_mod_Phi6,
#                data = PAM,
#                prior = pamDawn_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                warmup = n_warmup)

#-Save the best/final model-#
#saveRDS(pamDawn_brm_Phi6, "model outputs/pamDawn_brm_Phi6.RDS")
pamDawn_brm_Phi6 <- readRDS("model outputs/pamDawn_brm_Phi6.RDS")

#-Get credible intervals of best/final model-#
pamDawn_brm_Phi6
describe_posterior(pamDawn_brm_Phi6, ci = 0.65)
describe_posterior(pamDawn_brm_Phi6, ci = 0.95)

#-Model comparison using using WAIC and loo scores-#
# model_weights(pamDawn_brm_Phi, pamDawn_brm_Phi2, pamDawn_brm_Phi3, weights = "loo") #compare all models where day is continuous - 3 is best (no site or interaction)
# model_weights(pamDawn_brm_Phi4, pamDawn_brm_Phi5, pamDawn_brm_Phi6, weights = "loo") #compare all models where day is categorical - 6 is best (no site or interaction)
# model_weights(pamDawn_brm_Phi3, pamDawn_brm_Phi6, weights = "loo") # compare best continuous vs. best categorical - 6 is best (categorical)
# 
# model_weights(pamDawn_brm_Phi, pamDawn_brm_Phi2, pamDawn_brm_Phi3, weights = "waic") #compare all models where day is continuous - 3 is best (no site or interaction)
# model_weights(pamDawn_brm_Phi4, pamDawn_brm_Phi5, pamDawn_brm_Phi6, weights = "waic") #compare all models where day is categorical - 6 is best (no site or interaction)
# model_weights(pamDawn_brm_Phi3, pamDawn_brm_Phi6, weights = "waic") # compare best continuous vs. best categorical - 6 is best (categorical)

#-Conduct posterior predictive checks-#
# pp_check(pamDawn_brm_Phi3, ndraws = 100)
pp_check(pamDawn_brm_Phi6, ndraws = 100)
# pp_check(pamDawn_brm_Phi3, type = "dens_overlay_grouped", group = "Treatment", ndraws = 100)
pp_check(pamDawn_brm_Phi6, type = "dens_overlay_grouped", group = "Treatment", ndraws = 100)
# pp_check(pamDawn_brm_Phi3, type = "dens_overlay_grouped", group = "Day", ndraws = 100)
pp_check(pamDawn_brm_Phi6, type = "dens_overlay_grouped", group = "DayID", ndraws = 100) # looks slightly better
# pp_check(pamDawn_brm_Phi3,type = "loo_pit_overlay", ndraws = 100)
pp_check(pamDawn_brm_Phi6,type = "loo_pit_overlay", ndraws = 100) #this one looks slightly better

#-Get R2 score-# 
# bayes_R2(pamDawn_brm_Phi3)
bayes_R2(pamDawn_brm_Phi6)

#-Examine loo scores-# 
# loo(pamDawn_brm_Phi) 
# loo(pamDawn_brm_Phi2) 
# loo(pamDawn_brm_Phi3) 
# loo(pamDawn_brm_Phi4) 
# loo(pamDawn_brm_Phi5) 
loo(pamDawn_brm_Phi6) 

loo<- loo(pamDawn_brm_Phi6) 
loo::pareto_k_ids(loo, threshold = 0.7)

plot(loo,
  diagnostic = c("k"),
  label_points = FALSE,
  main = "PSIS diagnostic plot")

#-Examine conditional effects-# 
conditional_effects(pamDawn_brm_Phi6)

#-Get credible intervals of final model-#
describe_posterior(pamDawn_brm_Phi6, ci = 0.65)
describe_posterior(pamDawn_brm_Phi6, ci = 0.95)
```

### Figure 2B - Posterior estimates

```{r}
#-Get posterior draws for all parameter estimates-#
posterior_draws_pam <- pamDawn_brm_Phi6 %>%                                                                         # Extract posterior samples from 'pamDawn_brm_Phi6'
  posterior_samples() %>%                                                                                           # Extract posterior samples from the Bayesian model
  dplyr::select(-contains(c('cor', 'lp', 'Intercept', 'phi'))) %>%                                                  # Remove unwanted variables
  melt() %>%                                                                                                        # Reshape the data from wide to long format using the melt function
  as_tibble() %>%                                                                                                   # Convert the melted data to a tibble for easier manipulation
  mutate(Effect = ifelse(variable == "b_Treatment4", "4.0 mg/L DO",                                                 # Create a new variable 'Effect' based on 'variable'
                         ifelse(variable == "b_Treatment2", "2.0 mg/L DO", 
                                ifelse(variable == "b_Treatment0.5", "0.5 mg/L DO", 
                                       ifelse(variable == "b_DayID2", "Day 1", 
                                              ifelse(variable == "b_DayID3", "Day 2", 
                                                     ifelse(variable == "b_DayID4", "Day 3", 
                                                            ifelse(variable == "b_DayID5", "Day 4", NA)))))))) %>% 
  mutate(Order = ifelse(Effect == "4.0 mg/L DO", 1,                                                                 # Create a new variable to reorder the plot
                       ifelse(Effect == "2.0 mg/L DO", 2, 
                              ifelse(Effect == "0.5 mg/L DO", 3, 
                                     ifelse(Effect == "Day 1", 4, 
                                            ifelse(Effect == "Day 2", 5,
                                            ifelse(Effect == "Day 3", 6, 
                                                   ifelse(Effect == "Day 4", 7, NA))))))))  
colnames(posterior_draws_pam) <- c("effect", "effect_estimate", "Effect", "Order")                                  # Rename the columns of the resulting tibble

#-Plot posterior effect size estimates-#
(posterior_draws_pam_plot <- posterior_draws_pam %>%               # Create a ggplot object 'posterior_draws_pam_plot'.
  ggplot(aes(x = effect_estimate, y = reorder(Effect, -Order))) +  # Set aesthetics for the plot
  stat_halfeye() +                                                 # Add a half-eye plot
  geom_vline(xintercept = 0, size = 1.5, linetype = "dashed") +    # Add a vertical dashed line at 0
  theme_bw(base_size = 16) +                                       # Apply a black and white theme with a base font size of 16
  ylab("") +                                                       # Remove the y-axis label
  mytheme +                                                        # Apply custom theme
  coord_cartesian(c(-.2, .1)) +                                    # Set Cartesian coordinates to focus on a specific range
  xlab("Posterior effect size estimate"))                          # Set the x-axis label

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/pd_pam_28Nov23.svg", plot = posterior_draws_pam_plot, width = 7, height = 5)  # Save the plot as an SVG file
```

## II.  Symbiodiniaceae figures and models

### Figure 2C - Boxplots

```{r,message=FALSE}
acerZooxBoxplotNorm_noFacet <- ggplot(zooxNoDead) +                                                                                 # Create a ggplot object
  geom_boxplot(aes(y = log(zooxNorm), x = Treatment, color = Treatment), alpha = 0.9, size = 1) +                                   # Add a boxplot layer with log-transformed 'zooxNorm' values, grouped by 'Treatment'
  geom_point(aes(y = log(zooxNorm), x = Treatment, color = Treatment), position = position_jitterdodge(), alpha = 0.9, size = 3) +  # Add a jittered point layer with log-transformed 'zooxNorm' values, grouped by 'Treatment'
  labs(x = "Oxygen treatment", y = 'Symbiodinaceae density') +                                                                      # Set X and Y axis labels for the plot.
  scale_colour_manual(values = plot.col.treat) +                                                                                    # Manually set color scale for Treatment using specified values.
  scale_fill_manual(values = plot.col.treat) +                                                                                      # Manually set fill scale for Treatment using specified values.
  mytheme                                                                                                                           # Apply custom theme

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/acerZooxBoxplotNorm_29Nov23.svg", plot = acerZooxBoxplotNorm_noFacet, width = 7, height = 5) # Save the plot as an SVG file.
```

### Models

```{r}
hist(zooxNoDead$zooxNorm) # Create a histogram of the 'zooxNorm' variable

#-Define a Bayesian model for 'zooxNorm' with a separate formula for the shape parameter-#
#-Include fixed effects for 'Treatment', 'origin_site', and their interaction, and random effects for 'Geno' and 'Tank'-#
zoox_mod_shape <- bf(zooxNorm ~ 1 + Treatment + origin_site + origin_site*Treatment + (1|Geno) + (1|Tank),
                     shape ~ 1 + Treatment + origin_site + origin_site*Treatment + (1|Geno) + (1|Tank),
                     family = Gamma(link = "log"))

#-Define another Bayesian model for 'zooxNorm' with simplified fixed effects and random effects structure-#
zoox_mod_shape2 <- bf(zooxNorm ~ 1 + Treatment + origin_site + (1|Geno) + (1|Tank),
                      shape ~ 1 + Treatment + origin_site + (1|Geno) + (1|Tank),
                      family = Gamma(link = "log"))

#-Define another Bayesian model for 'zooxNorm' with further simplified fixed effects and random effects structure-#
zoox_mod_shape3 <- bf(zooxNorm ~ 1 + Treatment + (1|Geno) + (1|Tank),
                      shape ~ 1 + Treatment + (1|Geno) + (1|Tank),
                      family = Gamma(link = "log"))

#-Calculate mean of reference group for intercept parameter-#
zoox_mean <-  zooxNoDead %>%
  dplyr::group_by(Geno) %>%
  dplyr::summarize(logmeanZoox = log(mean(zooxNorm)))

print(paste("The logit-transformed zoox intercept is", round(zoox_mean[1,2], 2)))
# "The logit-transformed pamDawn intercept is 17.3"

#-Set priors-#
zoox_prior <- c(prior(normal(17.3, 2), class = "Intercept"),
                prior(normal(0, 1), class = "b"),
                prior(exponential(1), class = "sd"),
                prior(normal(17.3, 2), class = "Intercept", dpar = "shape"),
                prior(normal(0, 1), class = "b", dpar = "shape"))

#-Run models-#                          
# zoox_brm_shape <- brm(zoox_mod_shape,
#                data = zooxNoDead,
#                prior = zoox_prior,
#                cores = n_cores,
#                chains = n_chains,
#                init = "0",
#                iter = n_iter,
#                warmup = n_warmup)
# zoox_brm_shape2 <- brm(zoox_mod_shape2,
#                data = zooxNoDead,
#                prior = zoox_prior,
#                cores = n_cores,
#                chains = n_chains,
#                init = "0",
#                iter = n_iter,
#                warmup = n_warmup)
# zoox_brm_shape3 <- brm(zoox_mod_shape3,
#                data = zooxNoDead,
#                prior = zoox_prior,
#                cores = n_cores,
#                chains = n_chains,
#                init = "0",
#                iter = n_iter,
#                warmup = n_warmup)

#-Save the best/final model-#
#saveRDS(zoox_brm_shape3, "model outputs/zoox_brm_shape3.RDS")
zoox_brm_shape3<-readRDS("model outputs/zoox_brm_shape3.RDS")

#-Model comparison using using WAIC and loo scores-#
#model_weights(zoox_brm_shape, zoox_brm_shape2, zoox_brm_shape3, weights = "loo") 
#model_weights(zoox_brm_shape, zoox_brm_shape2, zoox_brm_shape3, weights = "waic") 

#-Conduct posterior predictive checks-#
pp_check(zoox_brm_shape3, type = "dens_overlay",  ndraws = 100)
pp_check(zoox_brm_shape3, type = "dens_overlay_grouped", group = "Treatment", ndraws = 100)
#pp_check(zoox_brm_shape2,type = "loo_pit_overlay", ndraws = 100)
pp_check(zoox_brm_shape3,type = "loo_pit_overlay", ndraws = 100) # better

#-Get R2 score-# 
#bayes_R2(zoox_brm_shape2) 
bayes_R2(zoox_brm_shape3) 

#-Examine loo scores-# 
#loo(zoox_brm_shape2)
loo(zoox_brm_shape3)

#-Examine conditional effects-# 
conditional_effects(zoox_brm_shape3)

#-Get credible intervals of final model-#
describe_posterior(zoox_brm_shape3, ci = .65)
describe_posterior(zoox_brm_shape3, ci = .95)
```

### Figure 2D - Posterior plots

```{r}
#-Get posterior draws for all parameter estimates-#
posterior_draws_zoox <- zoox_brm_shape3 %>%                                                           # Extract posterior samples from 'zoox_brm_shape3'
 posterior_samples()%>%                                                                               # Extract posterior samples from the Bayesian model
  dplyr::select(-contains(c('cor', 'phi', 'sd', 'lp', 'shape', 'Geno', 'Tank', 'Intercept'))) %>%     # Remove unwanted variables
  melt()%>%                                                                                           # Reshape the data from wide to long format using the melt function 
  as_tibble()%>%                                                                                      # Convert the melted data to a tibble for easier manipulation
   mutate(Effect = ifelse(variable == "b_Treatment4", "4.0 mg/L DO",                                  # Create a new variable 'Effect' based on 'variable'
                         ifelse(variable == "b_Treatment2", "2.0 mg/L DO", 
                                ifelse(variable == "b_Treatment0.5", "0.5 mg/L DO", NA))))%>%
  mutate(Order = ifelse(Effect == "4.0 mg/L DO", 1,                                                   # Create a new variable to reorder the plot
                       ifelse(Effect == "2.0 mg/L DO", 2, 
                              ifelse(Effect == "0.5 mg/L DO", 3, NA))))
colnames(posterior_draws_zoox) <- c("effect", "effect_estimate", "Effect", "Order")                   # Rename the columns of the resulting tibble

#-Plot posterior effect size estimates-#
(posterior_draws_zoox_plot <- posterior_draws_zoox %>%             # Create a ggplot object 'posterior_draws_zoox'
  ggplot(aes(x = effect_estimate, y = reorder(Effect, -Order))) +  # Set aesthetics for the plot
  stat_halfeye() +                                                 # Add a half-eye plot
  geom_vline(xintercept = 0, size = 1.5, linetype = "dashed") +    # Add a vertical dashed line at 0
  theme_bw(base_size = 16) +                                       # Apply a black and white theme with a base font size of 16
  ylab("") +                                                       # Remove the y-axis label
  mytheme +                                                        # Apply custom theme
  coord_cartesian(c(-1.5,.5))+                                     # Set Cartesian coordinates to focus on a specific range
  xlab("Posterior effect size estimate"))                          # Set the x-axis label

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/pd_zoox_28Nov23.svg", plot = posterior_draws_zoox_plot, width = 7, height = 5) # Save the plot as an SVG file.
```

## III. Tissue retention figures and models

### Figure 3A - Scatter plot

```{r}
(TLplot <- ggplot(TL, aes(x = Day, y = propTissueRemaining)) +              # Create a ggplot object 'TLplot' with specified aesthetics
    ylab("% tissue remaining") +                                            # Set the y-axis label
    xlab("Day") +                                                           # Set the x-axis label
    geom_jitter(aes(color = Treatment), alpha = 0.9, width = 0.15) +        # Add jittered points with color based on 'Treatment'
    geom_smooth(aes(color = Treatment, fill = Treatment), method = "lm") +  # Add a smoothed line with color and fill based on 'Treatment'
    scale_fill_manual(values = plot.col.treat) +                            # Manually set fill scale for 'Treatment' using specified values
    coord_cartesian(ylim=c(0,1)) +                                          # Set Cartesian coordinates to focus on the specified y-axis range
    scale_color_manual(values = plot.col.treat) +                           # Manually set color scale for 'Treatment' using specified values
    facet_wrap(facets = ~origin_site) +                                     # Facet the plot by 'origin_site'
    mytheme)                                                                # Apply custom theme

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/TLplot.svg", plot = TLplot, width = 7, height = 5) # Save the plot as an SVG file
```

### Models 

```{r}
hist(TL$propTissueRemaining) # Create a histogram of the 'propTissueRemaining' variable

#-Define a zero-inflated beta regression model for 'propTissueRemaining' with various fixed and random effects-#
zoibTR_mod <- bf(propTissueRemaining ~ 1 + Treatment + Day + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                 phi ~ 1 + Treatment + Day + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                 zoi ~ 1 + Treatment + Day + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                 coi ~ 1 + Treatment + Day + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                 family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Define another zero-inflated beta regression model with simplified fixed and random effects structure-#
zoibTR_mod2 <- bf(propTissueRemaining ~ 1 + Treatment + Day + origin_site + (1|Tank) + (1|Geno),
                  phi ~ 1 + Treatment + Day + origin_site + (1|Tank) + (1|Geno),
                  zoi ~ 1 + Treatment + Day + origin_site + (1|Tank) + (1|Geno),
                  coi ~ 1 + Treatment + Day + origin_site + (1|Tank) + (1|Geno),
                  family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Define another zero-inflated beta regression model with further simplified fixed and random effects structure-#
zoibTR_mod3 <- bf(propTissueRemaining ~ 1 + Treatment + Day + (1|Tank) + (1|Geno),
                  phi ~ 1 + Treatment + Day + (1|Tank) + (1|Geno),
                  zoi ~ 1 + Treatment + Day + (1|Tank) + (1|Geno),
                  coi ~ 1 + Treatment + Day + (1|Tank) + (1|Geno),
                  family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Define another zero-inflated beta regression model for 'propTissueRemaining' with DayID as an additional fixed effect-#
zoibTR_mod4 <- bf(propTissueRemaining ~ 1 + Treatment + DayID + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                  phi ~ 1 + Treatment + DayID + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                  zoi ~ 1 + Treatment + DayID + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                  coi ~ 1 + Treatment + DayID + origin_site + origin_site*Treatment + (1|Tank) + (1|Geno),
                  family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Define another zero-inflated beta regression model with simplified fixed and random effects structure and DayID-#
zoibTR_mod5 <- bf(propTissueRemaining ~ 1 + Treatment + DayID + origin_site + (1|Tank) + (1|Geno),
                  phi ~ 1 + Treatment + DayID + origin_site + (1|Tank) + (1|Geno),
                  zoi ~ 1 + Treatment + DayID + origin_site + (1|Tank) + (1|Geno),
                  coi ~ 1 + Treatment + DayID + origin_site + (1|Tank) + (1|Geno),
                  family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Define another zero-inflated beta regression model with further simplified fixed and random effects structure and DayID-#
zoibTR_mod6 <- bf(propTissueRemaining ~ 1 + Treatment + DayID + (1|Tank) + (1|Geno),
                  phi ~ 1 + Treatment + DayID + (1|Tank) + (1|Geno),
                  zoi ~ 1 + Treatment + DayID + (1|Tank) + (1|Geno),
                  coi ~ 1 + Treatment + DayID + (1|Tank) + (1|Geno),
                  family = zero_one_inflated_beta(link = "logit", link_phi = "log"))

#-Calculate mean of reference group for intercept parameter-#
TR_mean <- TL %>%
  filter(!is.na(propTissueRemaining))%>%
  dplyr::group_by(Geno) %>%
  dplyr::summarize(meanTR = mean(propTissueRemaining)) %>%
  mutate(logitmeanTR = logit(meanTR))

print(paste("The logit-transformed TR intercept is", round(TR_mean[1,3], 2)))
# "The logit-transformed TL intercept is 1.71"

#-Set priors-#
zoibTR_prior<- c(prior(normal(1.71, 1), class = "Intercept"),
               prior(normal(0, 1), class = "b"),
               prior(normal(0, 1), class = "b", dpar = "zoi"),
               prior(exponential(1), class = "sd", dpar = "zoi"),
               prior(normal(0, 1), class = "b", dpar = "coi"),
               prior(exponential(1), class = "sd", dpar = "coi"),
               prior(normal(1.71, 1), class = "Intercept", dpar = "phi"),
               prior(normal(0, 1), class = "b", dpar = "phi"),
               prior(normal(0, 1), class = "sd", dpar = "phi"),
               prior(exponential(1), class = "sd"))

#-Run models-#
# zoibTR_brm <- brm(zoibTR_mod,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# zoibTR_brm2 <- brm(zoibTR_mod2,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# zoibTR_brm3 <- brm(zoibTR_mod3,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# zoibTR_brm4 <- brm(zoibTR_mod4,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# zoibTR_brm5 <- brm(zoibTR_mod5,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# zoibTR_brm6 <- brm(zoibTR_mod6,
#                data = TL,
#                prior = zoibTR_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)

#-Save the best/final model-#
#saveRDS(zoibTR_brm, "model outputs/zoibTR_brm.RDS")
zoibTR_brm<-readRDS("model outputs/zoibTR_brm.RDS")

#-Model comparison using using WAIC and loo scores-#
# model_weights(zoibTR_brm, zoibTR_brm2, zoibTR_brm3, weights = "loo") 
# model_weights(zoibTR_brm, zoibTR_brm2, zoibTR_brm3, weights = "waic") 
# model_weights(zoibTR_brm4, zoibTR_brm5, zoibTR_brm6, weights = "loo") 
# model_weights(zoibTR_brm4, zoibTR_brm5, zoibTR_brm6, weights = "waic") 
# model_weights(zoibTR_brm, zoibTR_brm4, weights = "loo") 
# model_weights(zoibTR_brm, zoibTR_brm4, weights = "waic") 

#-Conduct posterior predictive checks-#
pp_check(zoibTR_brm, type = "dens_overlay",ndraws = 100)
pp_check(zoibTR_brm, type = "dens_overlay_grouped", group = "Treatment", ndraws = 100)
pp_check(zoibTR_brm, type = "dens_overlay_grouped", group = "origin_site", ndraws = 100)

#-Alternative to loo-pit posterior predictive check-#
y <- posterior_predict(zoibTR_brm)*100
yrep_int <- sapply(data.frame(y), as.integer)
y_int <- as.integer(TL$propTissueRemaining*100)
ppc_bars(y_int, yrep_int)
ppc_rootogram(y_int, yrep_int)

#-Get R2 score-#
bayes_R2(zoibTR_brm) 

#-Examine loo scores-# 
loo(zoibTR_brm)

#-Examine conditional effects-# 
conditional_effects(zoibTR_brm)

#-Get credible intervals of best/final model-#
zoibTR_brm
describe_posterior(zoibTR_brm, ci = 0.65)
describe_posterior(zoibTR_brm, ci = 0.95)
```

### Figure 3B - Posterior plots
```{r}
#-Get posterior draws for all parameter estimates-#
posterior_draws_TR <- zoibTR_brm %>%                                                                           # Extract posterior samples from zoibTR_brm
 posterior_samples()%>%                                                                                        # Extract posterior samples from the Bayesian model
  dplyr::select(-contains(c('cor', 'phi', 'sd', 'lp', 'coi', 'zoi', 'Tank', 'Geno', 'Intercept' ))) %>%        # Remove unwanted variables
  melt()%>%                                                                                                    # Reshape the data from wide to long format using the melt function 
  as_tibble()%>%                                                                                               # Convert the melted data to a tibble for easier manipulation
  mutate(Effect = ifelse(variable == "b_Treatment4", "4.0 mg/L DO",                                            # Create a new variable 'Effect' based on 'variable'
                         ifelse(variable == "b_Treatment2", "2.0 mg/L DO", 
                                ifelse(variable == "b_Treatment0.5", "0.5 mg/L DO", 
                                       ifelse(variable == "b_origin_siteinshore", "inshore site", 
                                               ifelse(variable == "b_Day", "Day", 
                                              ifelse(variable == "b_Treatment4:origin_siteinshore", "inshore * 4.0 mg/L", 
                                                     ifelse(variable == "b_Treatment2:origin_siteinshore", "inshore * 2.0 mg/L", 
                                                            ifelse(variable == "b_Treatment0.5:origin_siteinshore", "inshore * 0.5 mg/L", NA)))))))))%>%
  mutate(Order = ifelse(Effect == "4.0 mg/L DO", 1,                                                             # Create a new variable to reorder the plot
                       ifelse(Effect == "2.0 mg/L DO", 2, 
                              ifelse(Effect == "0.5 mg/L DO", 3, 
                                     ifelse(Effect == "inshore site", 4, 
                                            ifelse(Effect == "Day", 5, 
                                            ifelse(Effect == "inshore * 4.0 mg/L", 6, 
                                                   ifelse(Effect == "inshore * 2.0 mg/L", 7, 
                                                          ifelse(Effect == "inshore * 0.5 mg/L", 8, NA))))))))) 

colnames(posterior_draws_TR) <- c("effect", "effect_estimate", "Effect", "Order")                              # Rename the columns of the resulting tibble

#-Plot posterior effect size estimates-#
(posterior_draws_TR_plot <- posterior_draws_TR %>%                 # Create a ggplot object
  ggplot(aes(x = effect_estimate, y = reorder(Effect, -Order))) +  # Set aesthetics for the plot
  stat_halfeye() +                                                 # Add a half-eye plot
  geom_vline(xintercept = 0, size = 1.5, linetype = "dashed") +    # Add a vertical dashed line at 0
  theme_bw(base_size = 16) +                                       # Apply a black and white theme with a base font size of 16
  ylab("") +                                                       # Remove the y-axis label
  mytheme +                                                        # Apply custom theme
  coord_cartesian(c(-2,2))+                                        # Set Cartesian coordinates to focus on a specific range
  xlab("Posterior effect size estimate"))                          # Set the x-axis label

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/pd_tissueRetention.svg", plot = posterior_draws_TR_plot, width = 7, height = 7) # Save the plot as an SVG file

```

## IV. Survivorship figures and models

### Figure 3C - Scatter plot

```{r}
(survPlot <- ggplot(data = propSurvTrtSite, aes(x = DayID, y = propSurv)) +                  # Create a ggplot object 'survPlot' using data from 'propSurvTrtSite' with specified aesthetics
  ylab("% survivorship") +                                                                   # Set the y-axis label
  xlab("Day") +                                                                              # Set the x-axis label
  geom_point(aes(color = Treatment)) +                                                       # Add points with color based on 'Treatment'
  geom_smooth(aes(color = Treatment, fill = Treatment, group = Treatment), method = 'lm') +  # Add a smoothed line with color and fill based on 'Treatment'
  scale_fill_manual(values = plot.col.treat) +                                               # Manually set fill scale for 'Treatment' using specified values
  scale_color_manual(values = plot.col.treat) +                                              # Manually set color scale for 'Treatment' using specified values
  facet_wrap(facets = vars(origin_site)) +                                                   # Facet the plot by 'origin_site'
  coord_cartesian(ylim = c(0,1)) +                                                           # Set Cartesian coordinates to focus on the specified y-axis range
  mytheme)                                                                                   # Apply custom theme 'mytheme'

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/SurvTreatSitePlot.svg", plot = survPlot, width = 7, height = 5) # Save the plot as an SVG file
```

### Survivorship models

```{r}
# Define a logistic regression model for binary survival outcome ('surv') with various fixed and random effects.
surv_mod <- bf(surv ~ 1 + Treatment + Day + origin_site + Treatment*origin_site + (1|Geno) + (1|Tank),
               family = bernoulli(link = "logit"))

# Define another logistic regression model with simplified fixed and random effects structure.
surv_mod2 <- bf(surv ~ 1 + Treatment + Day + origin_site + (1|Geno) + (1|Tank),
                family = bernoulli(link = "logit"))

# Define another logistic regression model with further simplified fixed and random effects structure.
surv_mod3 <- bf(surv ~ 1 + Treatment + Day + (1|Geno) + (1|Tank),
                family = bernoulli(link = "logit"))

# Define another logistic regression model for binary survival outcome with DayID as an additional fixed effect.
surv_mod4 <- bf(surv ~ 1 + Treatment + DayID + origin_site + Treatment*origin_site + (1|Geno) + (1|Tank),
                family = bernoulli(link = "logit"))

# Define another logistic regression model with simplified fixed and random effects structure and DayID.
surv_mod5 <- bf(surv ~ 1 + Treatment + DayID + origin_site + (1|Geno) + (1|Tank),
                family = bernoulli(link = "logit"))

# Define another logistic regression model with further simplified fixed and random effects structure and DayID.
surv_mod6 <- bf(surv ~ 1 + Treatment + DayID + (1|Geno) + (1|Tank),
                family = bernoulli(link = "logit"))


#-Calculate mean of reference group for intercept parameter-#
surv_mean <- Surv %>%
  dplyr::group_by(Geno) %>%
  dplyr::summarize(meanSurv = mean(surv)) %>%
  mutate(logitmeanSurv = logit(meanSurv))

print(paste("The logit-transformed surv intercept is", round(surv_mean[1,3], 2))) # 3.14

#-Set priors-#
surv_prior <- c(prior(normal(3.14, 1), class = "Intercept"),
                prior(normal(0, 1), class = "b"),
                prior(exponential(2), class = "sd"))

#-Run models-#             
# surv_brm <- brm(surv_mod,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# surv_brm2 <- brm(surv_mod2,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# surv_brm3 <- brm(surv_mod3,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# surv_brm4 <- brm(surv_mod4,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# surv_brm5 <- brm(surv_mod5,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)
# 
# surv_brm6 <- brm(surv_mod6,
#                data = Surv,
#                prior = surv_prior,
#                cores = n_cores,
#                chains = n_chains,
#                iter = n_iter,
#                init = "0",
#                warmup = n_warmup)

#-Save the best/final model-#
#saveRDS(surv_brm, "model outputs/surv_brm.RDS")
surv_brm<-readRDS("model outputs/surv_brm.RDS")

#-Model comparison using using WAIC and loo scores-#
# model_weights(surv_brm, surv_brm2, surv_brm3, weights = "loo") 
# model_weights(surv_brm, surv_brm2, surv_brm3, weights = "waic") 
# model_weights(surv_brm4, surv_brm5, surv_brm6, weights = "loo")
# model_weights(surv_brm4, surv_brm5, surv_brm6, weights = "waic") 
# model_weights(surv_brm, surv_brm4, weights = "loo") 
# model_weights(surv_brm, surv_brm4,  weights = "waic") 

#-Get R2 score-# 
bayes_R2(surv_brm) 

#-Conduct posterior predictive checks-#
pp_check(surv_brm, type = "dens_overlay",ndraws = 100)
pp_check(surv_brm, type = "dens_overlay_grouped", group = "Treatment", ndraws = 100)
pp_check(surv_brm, type = "dens_overlay_grouped", group = "origin_site", ndraws = 100)

#-Alternative to loo-pit posterior predictive check-#
y <- posterior_predict(surv_brm)*100
yrep_int <- sapply(data.frame(y), as.integer)
y_int <- as.integer(Surv$surv*100)
ppc_bars(y_int, yrep_int)
ppc_rootogram(y_int, yrep_int)

#-Examine loo scores-# 
loo(surv_brm) 

#-Examine conditional effects-# 
conditional_effects(surv_brm)

#-Get credible intervals of best/final model-#
describe_posterior(surv_brm, ci = 0.95)
describe_posterior(surv_brm, ci = 0.65)
```

### Figure 3D - Posterior plots

```{r}
#-Get posterior draws for all parameter estimates-#
posterior_draws_surv <- surv_brm %>%                                                                                                                     # Extract posterior samples from
 posterior_samples()%>%                                                                                                                                  # Extract posterior samples from the Bayesian model
  dplyr::select(-contains(c( 'phi', 'sd', 'lp', 'Tank', 'Geno', 'Intercept'))) %>%                                                                       # Remove unwanted variables
  melt()%>%                                                                                                                                              # Reshape the data from wide to long format using the melt function 
  as_tibble()%>%                                                                                                                                         # Convert the melted data to a tibble for easier manipulation
   mutate(Effect = ifelse(variable == "b_Treatment4", "4.0 mg/L DO",                                                                                     # Create a new variable 'Effect' based on 'variable'
                         ifelse(variable == "b_Treatment2", "2.0 mg/L DO", 
                                ifelse(variable == "b_Treatment0.5", "0.5 mg/L DO", 
                                       ifelse(variable == "b_Day", "Day", 
                                       ifelse(variable == "b_origin_siteinshore", "inshore site", 
                                              ifelse(variable == "b_Treatment4:origin_siteinshore", "inshore * 4.0 mg/L", 
                                                     ifelse(variable == "b_Treatment2:origin_siteinshore", "inshore * 2.0 mg/L", 
                                                            ifelse(variable == "b_Treatment0.5:origin_siteinshore", "inshore * 0.5 mg/L", NA)))))))))%>%
  mutate(Order = ifelse(Effect == "4.0 mg/L DO", 1,                                                                                                      # Create a new variable to reorder the plot
                       ifelse(Effect == "2.0 mg/L DO", 2, 
                              ifelse(Effect == "0.5 mg/L DO", 3, 
                                     ifelse(Effect == "inshore site", 4, 
                                            ifelse(Effect == "Day", 5,
                                            ifelse(Effect == "inshore * 4.0 mg/L", 6, 
                                                   ifelse(Effect == "inshore * 2.0 mg/L", 7, 
                                                          ifelse(Effect == "inshore * 0.5 mg/L", 8, NA)))))))))
colnames(posterior_draws_surv) <- c("effect", "effect_estimate", "Effect", "Order")                                                                      # Rename the columns of the resulting tibble

#-Plot posterior effect size estimates-#
(posterior_draws_surv_plot <- posterior_draws_surv %>%             # Create a ggplot object
   ggplot(aes(x = effect_estimate, y = reorder(Effect, -Order))) + # Set aesthetics for the plot
  stat_halfeye() +                                                 # Add a half-eye plot
  geom_vline(xintercept = 0, size = 1.5, linetype = "dashed") +    # Add a vertical dashed line at 0
  theme_bw(base_size = 16) +                                       # Apply a black and white theme with a base font size of 16
  ylab("") +                                                       # Remove the y-axis label
  mytheme +                                                        # Apply custom theme
  coord_cartesian(c(-2.5,2.5))+                                    # Set Cartesian coordinates to focus on a specific range
  xlab("Posterior effect size estimate"))                          # Set the x-axis label

#-Save plot with specified parameters directly to a specific file path-#
ggsave(file = "fig/pd_survivorship_28Nov23.svg", plot = posterior_draws_surv_plot, width = 7, height = 5) # Save the plot as an SVG file
```